import * as _shared_clients_configurations from './configurations';
import { ConfigurationsClient } from './configurations';
import { AxiosResponse } from 'axios';

type TrimDataResponse<T extends {
    data?: unknown;
}> = Omit<AxiosResponse<T>, 'data'> & {
    data?: T['data'];
};
interface Storage<TStoredData extends object = object> {
    /**
     * Retrieves the value associated with a given key from the storage.
     * @param key - The key of the value to retrieve.
     * @returns A promise that resolves to the corresponding value, or undefined if not found.
     */
    get<TKey extends keyof TStoredData>(key: TKey): Promise<TStoredData[TKey] | undefined>;
    /**
     * Sets a value associated with a given key in the storage.
     * @param key - The key of the value to set.
     * @param value - The value to store.
     * @returns A promise that resolves when the operation is complete.
     */
    set<TKey extends keyof TStoredData>(key: TKey, value: TStoredData[TKey] | undefined): Promise<void>;
}
/**
 * Represents pagination options for querying items.
 */
interface Pagination {
    /**
     * Start time of the query, inclusive.
     */
    from?: string;
    /**
     * End time of the query, inclusive. Defaults to the current time.
     */
    to?: string;
    /**
     * Used to return items before the specified item exclusively.
     * SHOULD NOT be used in conjunction with `pageAfter`.
     */
    pageBefore?: string;
    /**
     * Used to return items after the specified item exclusively.
     * SHOULD NOT be used in conjunction with `pageBefore`.
     */
    pageAfter?: string;
    /**
     * The number of items to return.
     */
    pageSize?: number;
}
interface APIParams<TClient = unknown, TStoredData extends object = object> {
    /**
     * Storage solution for persisting data.
     */
    storage: Storage<TStoredData>;
    /**
     * An instance of the Main Client. Ready to be used.
     */
    client: TClient;
    /**
     * An instance of the ConfigurationsClient. Ready to be used.
     */
    configurationsClient: ConfigurationsClient;
}
interface ClientParams<TStoredData extends object = object> {
    /**
     * Api Key that is used to authenticate against Circle APIs.
     */
    apiKey: string;
    /**
     * Optional base URL to override the default: `https://api.circle.com`.
     */
    baseUrl?: string;
    /**
     * Optional custom user agent request header. We will prepend it to default user agent header if provided.
     */
    userAgent?: string;
    /**
     * Optional custom storage solution for persisting data. We will fallback to InMemoryStorage if none was provided.
     */
    storage?: Storage<TStoredData>;
}
type APIReturnType<T extends {
    data?: unknown;
}> = Promise<TrimDataResponse<T>>;
/**
 * Represents the configuration for setting fees.
 * It can be either FeeLevelInput, GasInput, or FeeInput.
 */
type FeeConfiguration<TFeeLevel> = {
    /**
     * Use absolute numbers to determine the fees that should be paid.
     */
    type: 'absolute';
    config: {
        /**
         * The maximum price per gas unit (see gasLimit), in gwei.
         * Requires baseFee, priorityFee, and gasLimit, but incompatible with feeLevel or gasPrice.
         * Use the Estimate Fee methods to get this fee's estimates.
         */
        maxFee: string;
        /**
         * The "tip", in gwei, added to the baseFee to incentivize validators.
         * Requires baseFee, maxFee, and gasLimit but incompatible with feeLevel or gasPrice.
         * Use the Estimate Fee methods for fee estimates.
         */
        priorityFee: string;
        /**
         * The maximum gas units for the transaction, required if feeLevel isn't provided.
         * Use the Estimate Fee methods for this limit's estimation.
         */
        gasLimit: string;
    };
} | {
    /**
     * Use gasLimit and gasPrice for fee determination.
     */
    type: 'gas';
    config: {
        /**
         * The maximum gas units for the transaction, required if feeLevel is not provided.
         * Use the Estimate Fee methods for this limit's estimation.
         */
        gasLimit: string;
        /**
         * For EIP-1559 supported blockchains, it's the max gas price per gas unit (see gasLimit), in gwei.
         * Requires gasLimit and incompatible with feeLevel, baseFee, priorityFee, or maxFee.
         * Use the Estimate Fee methods for fee estimates.
         */
        gasPrice: string;
    };
} | {
    /**
     * Use the fee level to configure the fees that will be paid.
     */
    type: 'level';
    config: {
        /**
         * A dynamic fee level setting (LOW, MEDIUM, HIGH) determining the gas price for the transaction,
         * based on network conditions. Incompatible with gasLimit, gasPrice, baseFee, priorityFee, or maxFee.
         * Use the Estimate Fee methods for fee level estimates.
         */
        feeLevel: TFeeLevel;
    };
};

declare const getPublicKey: ({ configurationsClient }: APIParams) => () => Promise<TrimDataResponse<_shared_clients_configurations.GetPublicKey200Response>>;

/**
 * Utility function to sanitize the Axios response object by:
 * - removing the redundant 'data' property when calling the 'data' property again on the Axios response
 * - casting the headers to `Record<string, string>` for better type assertion.
 * @param response - The Axios response object.
 * @returns - The sanitized response object.
 */
declare const trimData: <T extends {
    data?: unknown;
}>(response: AxiosResponse<T, any>) => TrimDataResponse<T>;

/**
 * Represents an in-memory storage implementation.
 */
declare class InMemoryStorage<TStoredData extends object> implements Storage<TStoredData> {
    private data;
    /**
     * Retrieves the value associated with the given key.
     * @param key - The key of the value to retrieve.
     * @returns A Promise that resolves to the value associated with the key, or undefined if the key doesn't exist.
     */
    get<TKey extends keyof TStoredData>(key: TKey): Promise<TStoredData[TKey] | undefined>;
    /**
     * Sets the value associated with the given key.
     * @param key - The key of the value to set.
     * @param value - The value to associate with the key. Use undefined to remove the key from the storage.
     * @returns A Promise that resolves once the value is set.
     */
    set<TKey extends keyof TStoredData>(key: TKey, value: TStoredData[TKey] | undefined): Promise<void>;
}

interface WithIdempotencyKey {
    /**
     * The optional idempotency key.
     * An idempotency key is a unique identifier used to identify and handle duplicate requests
     * in order to ensure idempotent behavior, where multiple identical requests have the same effect as a single request.
     *
     * We will generate one if you do not provide it.
     */
    idempotencyKey?: string;
}
type Cache = {
    /**
     * Public key of the entity.
     */
    publicKey: string;
};
type APIParamsWithEntitySecret<TStoredData extends Cache = Cache> = APIParams<unknown, TStoredData> & {
    /**
     * Your configured entity secret.
     */
    entitySecret: string;
};

/**
 * Method for securely encrypting an entity secret with a public key.
 * If the public key is not already stored, it fetches and stores it for future use.
 * @param params - Contains the entity secret and methods for managing storage.
 * @returns The encrypted entity secret, returned as a cipher text.
 */
declare const generateEntitySecretCiphertext: (params: APIParamsWithEntitySecret) => Promise<string>;

/**
 * Generates a unique idempotency key using the crypto library.
 * @returns A randomly generated idempotency key in UUID format.
 */
declare const generateIdempotencyKey: () => `${string}-${string}-${string}-${string}-${string}`;

export { type APIParams, type APIReturnType, type ClientParams, type FeeConfiguration, InMemoryStorage, type Pagination, type Storage, type TrimDataResponse, type WithIdempotencyKey, generateEntitySecretCiphertext, generateIdempotencyKey, getPublicKey, trimData };
